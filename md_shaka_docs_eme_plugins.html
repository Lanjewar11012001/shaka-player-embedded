<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Shaka Player Embedded: Custom EME Plugins</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Shaka Player Embedded
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Custom EME Plugins </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document describes how to create and register custom EME plugins. Defining a custom EME implementation allows the app to handle decrypting the media content without handling media-specific features. As of now, the EME implementations cannot handle decoding; they can only decrypt the bytes. This means you can't implement secure decrypt-decode or secure rendering.</p>
<h2>Overview</h2>
<p>First, you need to create the custom implementation types. You need to define derived types for <a class="el" href="classshaka_1_1eme_1_1Implementation.html">Implementation</a> and <a class="el" href="classshaka_1_1eme_1_1ImplementationFactory.html">ImplementationFactory</a>. There will be a single, global instance of the factory that is used to create instance of the Implementation. Each playback instance will get its own Implementation instance and there can be multiple alive at once if there are multiple Player instances.</p>
<h3>Registering your plugin</h3>
<p>Once you have written the type, you need to compile it into some library. You have two options:</p>
<p>First, you can compile your code into your app. You can do so any way you like. Then, before you create a Player instance, you need to create a global instance of your ImplementationFactory and register it with the <a class="el" href="classshaka_1_1eme_1_1ImplementationRegistry.html">ImplementationRegistry</a>. This factory instance must live for the duration of the app.</p>
<p>Second, you can compile your code into a separate library. Then you use the plugin definition below to register with our build system. When you build Shaka Player Embedded, our build system will include your library and include the plugin into the Embedded library. The implementation(s) will be automatically registered during library startup.</p>
<h2>Plugin Definition</h2>
<p>If you want, you can create a JSON definition of the plugin and have it built into the library. This means the plugin will be auto-registered and you just have to use the library like normal. This also allows you to keep the library and the plugin together and avoid versioning problems.</p>
<p>To define a plugin, you write a JSON file that describes your plugin. It should contain one or more libraries that will be built into the library. Then you indicate the headers where the implementations are found and we will generate code to register those types.</p>
<p>To register your JSON file, pass the <code>--eme-impl</code> flag to <code>./configure</code>. You can pass this multiple times for multiple implementations:</p>
<div class="fragment"><div class="line">./configure --eme-impl my-eme-def.json</div></div><!-- fragment --><h3>JSON definition</h3>
<table class="doxtable">
<tr>
<th>Field Name</th><th>Field Type</th><th>Description </th></tr>
<tr>
<td><code>libraries</code></td><td>array of strings </td><td>(optional) An array of paths to libraries to link against.  </td></tr>
<tr>
<td><code>implementations</code></td><td>array </td><td>An array of implementation definitions for the implementations this plugin defines.  </td></tr>
</table>
<a class="anchor" id=""></a>
<table class="doxtable">
<caption>Implementation definition</caption>
<tr>
<th>Field Name</th><th>Field Type</th><th>Description </th></tr>
<tr>
<td><code>factory_type</code></td><td>string </td><td>A (possibly qualified) type name to the ImplementationFactory type. See below for requirements.  </td></tr>
<tr>
<td><code>header</code></td><td>string </td><td>The path to the header that defines this type.  </td></tr>
<tr>
<td><code>key_system</code></td><td>string </td><td>The key system name that this implements. (e.g. <code>org.w3.clearkey</code>)  </td></tr>
<tr>
<td><code>sources</code></td><td>array of strings </td><td>(optional) An array of paths to source files to compile. These will be compiled into the library and can use internals.  </td></tr>
<tr>
<td><code>include_dirs</code></td><td>array of strings </td><td>(optional) An array of header search paths to include when building. Useful when giving <code>sources</code>.  </td></tr>
</table>
<h4>Example</h4>
<div class="fragment"><div class="line">{</div><div class="line">  &quot;libraries&quot;: [</div><div class="line">    &quot;build/cdm_adapter.a&quot;</div><div class="line">  ],</div><div class="line">  &quot;implementations&quot;: [</div><div class="line">    {</div><div class="line">      &quot;factory_type&quot;: &quot;my_ns::MyImplementationFactory&quot;,</div><div class="line">      &quot;header&quot;: &quot;include/my_implementation_factory.h&quot;,</div><div class="line">      &quot;key_system&quot;: &quot;com.example.cdm&quot;</div><div class="line">    }</div><div class="line">  ]</div><div class="line">}</div></div><!-- fragment --><h3>Dynamic libraries</h3>
<p>It is suggested to use a static library to make building easier. But you can use a dynamic library or a framework instead. For iOS builds, the library or framework will be copied into the compiled framework; for non-iOS builds, you are responsible for copying the dynamic library to the install directory so the library loader can find it at runtime.</p>
<h4>Factory requirements</h4>
<p>Each implementation factory defined by the plugin must publicly implement the ImplementationFactory type and must have an empty constructor. The factory will be allocated using <code>new</code>. For static libraries, the type doesn't need to be exported.</p>
<h4>Paths</h4>
<p>File paths in the JSON file can be absolute; if they are relative, they are relative to the JSON file. File paths can include format specifiers to give different paths based on what is currently being built. The format specifier is in the format <code>%(name)s</code> where name is one of the below names. For example, <code>foo/%(config)s/bar</code> may give <code>foo/Debug/bar</code>.</p>
<table class="doxtable">
<tr>
<th>Name </th><th>Description </th><th>Possible values  </th></tr>
<tr>
<td>config </td><td>The current configuration name </td><td><code>Debug</code> or <code>Release</code> </td></tr>
<tr>
<td>arch </td><td>The target CPU architecture </td><td><code>x86</code>, <code>x64</code>, <code>arm</code>, or <code>arm64</code> </td></tr>
<tr>
<td>os </td><td>The target OS </td><td><code>linux</code>, <code>mac</code>, <code>win</code>, <code>ios</code>, or <code>android</code> </td></tr>
</table>
<h4>Building plugin from source</h4>
<p>It is possible to build your plugin from source instead of from a static library. If you pass the <code>sources</code> field, those files will be compiled into the library. This allows access to the library internals. For example, this can be used so your plugin can use the <a class="el" href="classshaka_1_1util_1_1FileSystem.html">FileSystem</a> type to avoid duplicating code. Note that internals are not ABI or API stable, so they may change at any time. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
